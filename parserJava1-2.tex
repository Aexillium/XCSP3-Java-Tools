\documentclass[10pt]{article}

\usepackage[table]{xcolor}
\usepackage{mathrsfs} % for mathscr
\usepackage{amssymb,amsmath}
\usepackage{graphicx}
\usepackage{hyperref} 
\usepackage{multirow}
%\usepackage{scrextend}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{enumitem} 
\usepackage{caption} 
\usepackage{subcaption} 
\usepackage{comment}
\usepackage{longtable}

% tuning toc, chapters, list items
\hypersetup{colorlinks,linkcolor={red!50!black},citecolor={blue!50!black},urlcolor={blue!80!black}}
\usepackage[toc,page]{appendix}
\usepackage[top=1.5in, bottom=1.5in, left=1.41in, right=1.41in]{geometry}
\usepackage{titlesec}
\newcommand{\chapnumfont}{\usefont{T1}{pnc}{b}{n}\fontsize{100}{100}\selectfont}
\colorlet{chapnumcol}{gray!75}  % color for chapter number
\titleformat{\chapter}[display]{\filleft\bfseries}{\filleft\chapnumfont\textcolor{chapnumcol}{\thechapter}}{-24pt}{\Huge}
\setlist{topsep=2.2pt,itemsep=0.5pt} %nolistsep}%\setlist[itemize]{itemsep=0.5pt}

\usepackage{tikz}
\usetikzlibrary{shapes,calc,positioning,automata,arrows,trees}

\usepackage[tikz]{bclogo}
\renewcommand\logowidth{15pt}
\newcommand\bcpenr{\includegraphics[width=\logowidth]{crayonRed.png}} 
\newcommand\bcpen{\includegraphics[width=\logowidth]{figures/crayonBlue.png}} 
\newcommand\bcdico{\includegraphics[width=\logowidth]{figures/bookJaune.png}} 
\newcommand\bcroue{\includegraphics[width=\logowidth]{figures/roue.png}} 
%\renewcommand\bcStyleTitre[1]{\large\textbf{#1}}

\newcounter{cntM3}
\newcounter{cntSy}
\newcounter{cntSe}
\newcounter{cntEx}

\usepackage{listingsutf8}

\lstdefinelanguage{syntax}{
  keywords={realExpr,rankType,orderedType,iaBaseRelation,paBaseRelation,rcc8BaseRelation,measureType,combinationType,blockType,decimal,branchingType,restartsType,consistencyType,filteringType,varhType,valhType,intCtr,integer,unsignedInteger,constraint,metaConstraint,intExpr,boolExpr,boolExprSet,boolExprReal,wspace,dimensions,realVar,realVal,qualVar,graphVar,node,varType,setVar,setVal,frameworkType,proba,intIntvl,realIntvl,number,intVar,intVal,symbol,operator,operand,boolean,identifier,state,restrictionList},
  keywordstyle=\color{dblue}\slshape,
  basewidth  = {.5em,0.5em},
  %title={\bf Syntax},%
  escapechar=@,
  %caption={\bf Syntax},nolol,captionpos=t,belowcaptionskip=2pt,frame=single,rulesep=2pt,
  xleftmargin=1pt,xrightmargin=1pt,
  breaklines=true,basicstyle=\ttfamily\linespread{1.0}\small,backgroundcolor=\color{colorsy},inputencoding=utf8/latin9,texcl
}

\lstdefinelanguage{semantics}{
  keywords={identifier}, 
  basewidth  = {.5em,0.5em},
  %title={\bf Semantics}, 
  escapechar=@,
  %comment=[l]{//},
  %commentstyle=\color{dgray}\ttfamily,
  %nolol,captionpos=t,belowcaptionskip=2pt,
  %frame=single,
  %rulesep=2pt,
  xleftmargin=1pt,xrightmargin=1pt,
  breaklines=true,basicstyle=\ttfamily\linespread{1.20}\small,backgroundcolor=\color{colorse},inputencoding=utf8/latin9,texcl,mathescape
}

\lstdefinelanguage{xcsp}{
  keywords={region,instance,variables,literals,var,domain,constraints,objectives,annotations,annotation,array,extension,intension, tuples, supports,conflicts,args,quantification,fuzzy,relation,interval,point,agents,agent,allDifferent,count,ordered,vars,ctrs,comm,stages,decision, stochastic,required,possible,nodes,edges,arcs,minimize,maximize,linear,operator,value,allEqual,among,atLeast,atMost,exactly,limit,cumulative,circuit,regular,mdd,hamming,channel,element,values,transitions,origins,durations,indexes,permutation,coeffs,nValues,clause,cube,sort,lex,precedence,cardPath,slide,slidingAmong,slidingSum,sequence,gsc,seqbin,binPacking,maximum,minimum, hardTemplate,softTemplate,capacities,loads,intervals,costMatrix,knapsack,allDisjoint,overlap,exists,forall,aggregate,dbd,output,min,max,varHeuristic,valHeuristic,lastConflict,vals,BC, AC, FC, prepro, search, filtering, restarts,group,width, widths, stretch,lengths,block,start,final,balance,path,tree, root, succs, range, image, allDistant, roots, capacity, bins, sizes, heights,and, or, except, function, matrix, sumCosts, increasing, index, list,lists,set,mset,terminal,rules,grammar,mapping,cards, ranges, rowCards, colCards, indexes, not, allIntersecting, costMeasure, accept, limits, relation, sum, comparison, operand, condition, conditions, nCircuits, nPaths, nTrees, rowOccurs, colOccurs, occurs, noOverlap,cost, total, number, cardinality, scope, static
},
  basewidth  = {.6em,0.6em},
  keywordstyle=\color{mblue}\bfseries,
  ndkeywords={of,consistency,branching,lc,combination,defaultDegree,id, size, startIndex, format, type, reifiedBy, hreifiedFrom, hreifiedTo, as, measure, degree, threshold, cutoff, factor, varsModel, ctrsModel, commModel, for, case, closed, rank, restriction, circular, offset, collect, window, violable, order , defaultCost},
  ndkeywordstyle=\color{dviolet}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{dred}\ttfamily,
  stringstyle=\color{dgreen}\ttfamily,
  morestring=[b]',
  morestring=[b]",
  %title={\bf Example}, 
  escapechar=@,
  %framerule=1pt,
  %framesep=0pt,
  %numberstyle=\large,
  %nolol,captionpos=t,belowcaptionskip=2pt,
  %frame=shadowbox,
  %rulesep=2pt,
  showstringspaces=false,
  xleftmargin=1pt,xrightmargin=1pt,
  %rulesepcolor=\color{bgray},frameround=ffff,
  breaklines=true,basicstyle=\ttfamily\small,backgroundcolor=\color{colorex},inputencoding=utf8/latin9,texcl
}

%\def\bw{1}
\ifx\bw\undefined
  \lstnewenvironment{syntax}{\lstset{language=syntax}}{}
  \lstnewenvironment{semantics}{\lstset{language=semantics}}{}
  \lstnewenvironment{xcsp}{\lstset{language=xcsp}}{} 
  \newenvironment{boxsy}
               {\medskip
                 %\begin{addmargin}[-0.5cm]{-0.5cm}
                   \stepcounter{cntSy} \begin{bclogo}[couleur = colorsy,couleurBord=dgray,epBord=0.01,arrondi=0.2,couleurOmbre=dgray,ombre=true,epOmbre=0.05,logo=\bcpen]{ Syntax \thecntSy} \vspace{-0.1cm}}
               {\vspace{-0.1cm}\end{bclogo}
                 %\end{addmargin}
                  ~ \vspace{-0.2cm}}
  \newenvironment{boxse}
               {\medskip \stepcounter{cntSe} \begin{bclogo}[couleur = colorse,couleurBord=dgray,epBord=0.01,arrondi=0.2,couleurOmbre=dgray,ombre=true,epOmbre=0.05,logo=\bcdico]{ Semantics \thecntSe}\vspace{-0.1cm}}
               {\vspace{-0.1cm}\end{bclogo} ~ \vspace{-0.2cm}} %\medskip}
  \newenvironment{boxex}
               {\medskip \stepcounter{cntEx} \begin{bclogo}[couleur = colorex,couleurBord=dgray,epBord=0.01,arrondi=0.2,couleurOmbre=dgray,ombre=true,epOmbre=0.05,logo=\bcroue]{ Example \thecntEx}\vspace{-0.1cm}}
               {\vspace{-0.1cm}\end{bclogo} ~ \vspace{-0.2cm}} %\medskip}
  \newenvironment{simplex}
               {\medskip \begin{bclogo}[couleur = colorex,couleurBord=dgray,epBord=0.01,arrondi=0.2,couleurOmbre=dgray,ombre=true,epOmbre=0.05,barre=none,logo=]{}\vspace{-0.5cm}}
               {\vspace{-0.1cm}\end{bclogo} \medskip}
\else
  \lstnewenvironment{syntax}{\lstset{language=syntax,backgroundcolor=\color{white}}}{}
  \lstnewenvironment{semantics}{\lstset{language=semantics,backgroundcolor=\color{white}}}{}
  \lstnewenvironment{xcsp}{\lstset{language=xcsp,backgroundcolor=\color{white}}}{}
  \newenvironment{boxsy}
               {\medskip \stepcounter{cntSy} \begin{bclogo}[barre=none,logo=]{ Syntax \thecntSy}\vspace{-0.1cm}}
               {\vspace{-0.1cm}\end{bclogo} \medskip ~ \vspace{-0.3cm}}
  \newenvironment{boxse}
               {\medskip \stepcounter{cntSe} \begin{bclogo}[barre=none,logo=]{ Semantics \thecntSe}\vspace{-0.1cm}}
               {\vspace{-0.1cm}\end{bclogo} \medskip}
  \newenvironment{boxex}
               {\medskip \stepcounter{cntEx} \begin{bclogo}[barre=none,logo=]{ Example \thecntEx}\vspace{-0.1cm}}
               {\vspace{-0.1cm}\end{bclogo} \medskip}
  \newenvironment{simplex}
               {\medskip \begin{bclogo}[barre=none,logo=]{}\vspace{-0.5cm}}
               {\vspace{-0.1cm}\end{bclogo} \medskip}
\fi
\lstdefinelanguage{absc}{
  keywords={specifyArguments,specifyVariables,specifyConstraints, specifyObjectives,Problem
},
  basewidth  = {.6em,0.6em},
  keywordstyle=\color{mblue}\bfseries,
  ndkeywords={id},
  ndkeywordstyle=\color{dviolet}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{dred}\ttfamily,
  stringstyle=\color{dgreen}\ttfamily,
  morestring=[b]',
  morestring=[b]",
  %title={\bf Example}, 
  escapechar=@,
  %framerule=1pt,
  %framesep=0pt,
  %numberstyle=\large,
  %nolol,captionpos=t,belowcaptionskip=2pt,
  %frame=shadowbox,
  %rulesep=2pt,
  showstringspaces=false,
  xleftmargin=1pt,xrightmargin=1pt,
  %rulesepcolor=\color{bgray},frameround=ffff,
  breaklines=true,basicstyle=\ttfamily\police,backgroundcolor=\color{colorex},inputencoding=utf8/latin9,texcl
}
\lstnewenvironment{absc}{\lstset{language=absc,basicstyle=\ttfamily\scriptsize,backgroundcolor=\color{white}}}{}
\newenvironment{boxabsc}
               {\medskip \begin{bclogo}[barre=none,arrondi=0.2,logo=]{}\vspace{-0.6cm}}
               {\vspace{-0.1cm}\end{bclogo} \smallskip}

\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{remarks}{Remarks}

\definecolor{v2lgray}{gray}{0.85}
\definecolor{vlgray}{gray}{0.92}
\definecolor{mygray}{rgb}{0.92,0.98,0.92}
\definecolor{bgray}{rgb}{0.8,0.8,0.8}
\definecolor{dgray}{rgb}{0.4,0.4,0.4}
\definecolor{dblue}{RGB}{0,0,99}
\definecolor{dred}{RGB}{150,6,54}
\definecolor{dgreen}{RGB}{47,135,7}
\definecolor{d2green}{RGB}{47,85,7}
\definecolor{dviolet}{RGB}{102,0,153}
\definecolor{mblue}{RGB}{0,0,180}
\definecolor{m2blue}{RGB}{0,0,220}
\definecolor{colorse}{RGB}{255,248,220}
\definecolor{colorsy}{HTML}{F2F2F2}
\definecolor{colorex}{HTML}{FFE3BE}


\def\N{\mathbb{N}}
\def\Q{\mathbb{Q}}
\def\D{{\mathsf{D}}}
\def\B{{\mathsf{B}}}
\def\DINT{{\mathsf{D}_\mathsf{int}}}
\def\BINT{{\mathsf B}_\mathsf{int}} 
\def\ti{\textrm{-}}
\def\tr{\;\!\triangleright}
\def\st{\!:\!}

\def\gecode{Gecode\xspace}
\def\choco{Choco3\xspace}
\def\abscon{AbsCon\xspace}
\def\mzinc{MiniZinc\xspace}
\def\jacop{JaCoP\xspace}
\def\minion{Minion\xspace}
\def\xt{{\rm XCSP3}\xspace}
\def\cat{Global Constraint Catalog\xspace}



\newcommand{\xml}[1]{{\tt <#1>}} % xml element names
\newcommand{\att}[1]{{\tt #1}} % attribute names
\newcommand{\val}[1]{{\tt "#1"}} % attribute values

\newcommand{\bnf}[1]{\textsl{\color{dblue}{#1}}}
\newcommand{\bnfX}[1]{\texttt{<}\bnf{#1}\texttt{.../>}}
\newcommand{\norX}[1]{\texttt{<#1.../>}}


%\newcommand{\gb}[1]{\textcolor{dgreen}{{\tt #1}}} % global constraint names
\newcommand{\gb}[1]{{\tt #1}} % global constraint names
\newcommand{\gbc}[1]{\textcolor{dblue}{{\mathit #1}}} % global constraint names
\newcommand{\nn}[1]{{\tt #1}} % name normal
\newcommand{\nm}[1]{\mathit{#1}} % name math
\newcommand{\sy}[1]{{\ttfamily {\slshape #1}}}  % syntax elements like intValue etc.
\newcommand{\ns}[1]{{\mathcal #1}}  % symbol for set variables
\newcommand{\nss}[1]{{\mathbfcal #1}}  % symbol for set variables

\newcommand*{\com}[1]{\hfill \textcolor{dgray}{// #1}} % comment in lstlisting
\newcommand{\violet}[1]{{\small \textcolor{dviolet}{#1}}}

\newcommand{\va}[1]{{\boldsymbol #1}} % value of variable (for semantics)
%\newcommand{\va}[1]{\underline{#1}} % value of variable (for semantics)
%\newcommand{\va}[1]{#1} % value of variable (for semantics)

%\newcommand{\todoguys}[1]{\fbox{{\textcolor{red}{{\bf TODO : #1}}}}}

\tikzset{
  dirtree/.style={
    grow via three points={one child at (0.8,-0.7) and two children at (0.8,-0.7) and (0.8,-1.45)}, 
    edge from parent path={($(\tikzparentnode\tikzparentanchor)+(.4cm,0cm)$) |- (\tikzchildnode\tikzchildanchor)}, growth parent anchor=west, parent anchor=south west},
}

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3} 



\title{\textcolor{dred}{Java Parser for \xt}\\ \textcolor{dred}{Version 1.2}}
\author{Christophe Lecoutre \\
CRIL CNRS, UMR 8188\\ University of Artois, France \\
%\\ Rue de l'universit\'e, SP 16\\ 62307 Lens, France \\
lecoutre@cril.fr
}

\date{May 19, 2016}



\begin{document}
\maketitle


The version 1.2 of the \xt Java Parser recognizes almost all concepts of \xt.
Its current limitations are the following:
\begin{itemize}
\item the attribute \att{as} can only be used for variables and arrays of variables (but for the moment, no instance among the $15,000$ that have been generated, exploits this attribute differently).
\item compressed tuples are not handled (but shortened tuples are).
\end{itemize}


\bigskip
Note that this is a Java parser that uses DOM (Document Object Model) to parse XCSP3 instances.
However, feel free to adapt it.

\bigskip
As mentioned above, the Java parser (class \nn{XParser}) is rather complete.
It allows scanning an XCSP3 file and to build a pre-digested representation of the various objects of the instance.
However to simplify things, we propose an interface that is composed of callback functions.
This interface corresponds to classes  \nn{XCallbacks} and \nn{XCallbacks2}.
Currently, this interface has been developed for XCSP3-core, i.e., for integer variables, the 20 most popular constraints over integer variables, and mono-optimization.
This interface will be progressively extended.

\bigskip
To start, once you have imported the classes required to parse (with DOM) \xt instances, 
you should start writing (in Java 8) something like:

\begin{boxabsc}
\begin{absc}
class XCSP3 implements XCallbacks2 { 

  XCSP3(String fileName) throws Exception {
    Document document = XUtility.loadDocument(fileName);
  }
}  
\end{absc} 
\end{boxabsc}

If when running this code on a given filename, an exception is not raised, that's fine (maybe, as a first attempt, use an uncompressed file as for example, \nn{queens8.xml} instead of  \nn{queens8.xml.lzma}).
Otherwise, you may need to redefine the way you can convert an XCSP3 file (whose name is given) into an object Document, as follows:

\begin{boxabsc}
\begin{absc}
class XCSP3 implements XCallbacks2 { 
  public Document loadDocument(String fileName) throws Exception {
    // put your code here to convert the file, whose name is given, into a Document
    // See the code in XUtility.loadDocument(fileName) for a hint
  }

  XCSP3(String fileName) throws Exception {
    Document doc = XUtility.loadDocument(fileName);
  }
}  
\end{absc} 
\end{boxabsc}

Now, assume that everything is fine with the loading of the document.
To parse the document, we build an object \nn{XParser}, and then we can interact with all entries that were initially in \xml{variables}, \xml{constraints} and \xml{objectives}.
These entries are respectively stored in \nn{parser.vEntries}, \nn{parser.cEntries} and \nn{parser.oEntries}.
Here, we just display the description of all these entries.

\begin{boxabsc}
\begin{absc}
class XCSP3 implements XCallbacks2 { 

  XCSP3(String fileName) throws Exception {
    Document document = XUtility.loadDocument(fileName);
    XParser parser = new XParser(document);
    parser.vEntries.stream().forEach(e -> System.out.println(e.toString()));
    parser.cEntries.stream().forEach(e -> System.out.println(e.toString()));
    parser.oEntries.stream().forEach(e -> System.out.println(e.toString()));
  }
}  
\end{absc} 
\end{boxabsc}

Now, consider the following instance \nn{testExtension1.xml}:

\begin{boxabsc}
\begin{absc}
<instance format="XCSP3" type="CSP">
  <variables>
    <var id="x0"> 0 1 </var>
    <var id="x1"> 0 1 </var>
    <var id="x2"> 0 1 </var>
    <var id="x3"> 0 1 </var>
    <var id="x4"> 0 1 </var>
    <var id="x5"> 0 1 </var>
    <var id="x6"> 0 1 </var>
  </variables>
  <constraints>
    <extension>
      <list> x4 x5 x0 </list>
      <supports> (0,0,1)(0,1,0)(1,0,0)(1,1,1) </supports>
    </extension>
    <extension>
      <list> x0 x6 x1 </list>
      <supports> (0,0,1)(0,1,0)(1,0,0)(1,1,1) </supports>
    </extension>
    <extension>
      <list> x3 x6 x2 </list>
      <supports> (0,0,1)(0,1,0)(1,0,0)(1,1,1) </supports>
    </extension>
    <extension>
      <list> x4 x5 x3 </list>
      <supports> (0,0,0)(0,1,1)(1,0,1)(1,1,0) </supports>
    </extension>
  </constraints>
</instance>
\end{absc} 
\end{boxabsc}

and simplify your code so as to just have:

\begin{boxabsc}
\begin{absc}
class XCSP3 implements XCallbacks2 { 
  XCSP3(String fileName) throws Exception {
    loadInstance(fileName); 
  }
}  
\end{absc} 
\end{boxabsc}

\begin{remark}
You can provide the name of the classes that you want to discard when calling the XParser constructor. For example, \verb!parser = new XParser(fileName,"symmetryBreaking");! But this is an advanced use.
\end{remark}

When you execute the code for the instance \nn{testExtension1.xml} above, you must obtain something like:

\begin{boxabsc}
\begin{absc}
Missing Implementation
  Method buildVarInteger
  Class org.xcsp.parser.XCallbacks2
  Line 105
\end{absc} 
\end{boxabsc}	

Here, is is indicated that a method whose name is \nn{buildVarInteger} needs to be implemented.
Indeed, to manage integer variables, we have to implement the two following methods:

\begin{boxabsc}
\begin{absc}
 public void buildVarInteger(XVarInteger x, int minValue, int maxValue);
 public void buildVarInteger(XVarInteger x, int[] values);
\end{absc} 
\end{boxabsc}

For managing variables, it seems relevant to introduce a map for making the correspondence between the variables in the parser (\nn{XVarInteger} objects) and the variables in your solver (assumed to correspond to \nn{VarInteger} objects).
%We also need to convert the domains managed in the parser  (\nn{XDomInteger} objects) and the domains in your solver (assumed to correspond to \nn{DomInteger} objects).
Note that:
\begin{itemize}
\item  minValue may be equal to \nn{XConstants.VAL\_MINUS\_INFINITY\_INT}, for denoting $- \infty$, and 
\item maxValue  may be equal to \nn{XConstants.VAL\_PLUS\_INFINITY\_INT}, for denoting $+ \infty$.
\end{itemize}
but we have no such a case for the first 60 problems (and $15,000$ generated instances) we have modeled.

\begin{boxabsc}
\begin{absc}
class XCSP3 implements XCallbacks2 { 
  private Map<XVarInteger, VarInteger> mapVar = new LinkedHashMap<>();

  public void buildVarInteger(XVarInteger xx, int minValue, int maxValue) {
    VarInteger x = ...  // build your solver variable x here using xx.id, minValue and maxValue
    mapVar.put(xx,x);  
  }

  public void buildVarInteger(XVarInteger xx, int[] values) { 
    VarInteger x = ... // build your solver variable x here using xx.id and values
    mapVar.put(xx,x);  
  }
  
  XCSP3(String fileName) throws Exception {
    loadInstance(fileName); 
  }
}
\end{absc} 
\end{boxabsc}


\begin{remark}
The parser automatically flattens all variables from arrays. Also, all variables with degree 0 (i.e., all useless variables that occur in no constraint and no objective) are automatically discarded. 
If you want to execute specific code, you can override the following methods from \nn{XCallbacks}:
\begin{absc}
  public void loadVariables(XParser parser) 
  public void loadVar(XVar v, Map<XDom, Object> cache4DomObject)
  public void loadArray(XArray va, Map<XDom, Object> cache4DomObject) 
\end{absc} 
\end{remark}

Now, when you execute the code for the instance \nn{testExtension1.xml} above, you must obtain something like:

\begin{boxabsc}
\begin{absc}
Missing Implementation
  Method buildCtrExtension
  Class org.xcsp.parser.XCallbacks2
  Line 129
\end{absc} 
\end{boxabsc}
 
The implementation of a required method is missing here. Because, most of the time, we shall have to translate parser variables into solver variables, we propose first to add the following auxiliary functions:

\begin{boxabsc}
\begin{absc}
  private VarInteger trVar(Object var) {
    return mapVar.get((XVarInteger) var);
  }
  
  private VarInteger[] trVars(Object vars) {
    return Arrays.stream((XVarInteger[]) vars).map(v -> mapVar.get(v)).toArray(VarInteger[]::new);
  }
  
  private VarInteger[][] trVars2D(Object vars) {
    return Arrays.stream((XVarInteger[][]) vars).map(t -> trVars(t)).toArray(VarInteger[][]::new);
  }
\end{absc} 
\end{boxabsc}


And now, assuming that you can call a method \nn{extension} to build an extensional constraint in your solver, you can add:
	
\begin{boxabsc}
\begin{absc}
  public void buildCtrExtension(String id, XVarInteger[] list, int[][] tuples, boolean positive, Set<TypeFlag> flags) {
    if (flags.contains(TypeFlag.STARRED_TUPLES)) {
      ... // can you manage tables with symbol * ?
    }
    if (flags.contains(TypeFlag.UNCLEAN_TUPLES)) {
      ... // do you have to clean the tuples, so as to remove those that cannot be built from variable domains ?
    }
    extension(trVars(list), tuples, positive);
  }
\end{absc} 
\end{boxabsc}

The specified Boolean argument indicates is the table is positive (set of tuples seen as supports) or negative (set of tuples seen as conflicts). Note that we have a set as last argument for the method. It allows us to know if * is present in any tuple, and if all tuples are present in the Cartesian product of the variable domains.
If everything is ok, you should get 8 solutions for the instance \nn{testExtension1.xml}.
Check that you obtain the same result with the equivalent instance \nn{testExtension2.xml} that uses an array instead of stand-alone variables.

\begin{boxabsc}
\begin{absc}
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" size="[7]"> 0 1 </array>
  </variables>
  <constraints>
    <extension>
      <list> x[4..5] x[0] </list>
      <supports> (0,0,1)(0,1,0)(1,0,0)(1,1,1) </supports>
    </extension>
    <extension>
      <list> x[0] x[6] x[1] </list>
      <supports> (0,0,1)(0,1,0)(1,0,0)(1,1,1) </supports>
    </extension>
    <extension>
      <list> x[3] x[6] x[2] </list>
      <supports> (0,0,1)(0,1,0)(1,0,0)(1,1,1) </supports>
    </extension>
    <extension>
      <list> x[4] x[5] x[3] </list>
      <supports> (0,0,0)(0,1,1)(1,0,1)(1,1,0) </supports>
    </extension>
  </constraints>
</instance>
\end{absc} 
\end{boxabsc}


For dealing with unary extensional constraints, you have to implement:
\begin{boxabsc}
\begin{absc}
public void buildCtrExtension(String id, XVarInteger x, int[] values, boolean positive, Set<TypeFlag> flags);
\end{absc} 
\end{boxabsc}

\begin{remark}
When a constraint is recognized as totally entailed (no conflicts) or totally disentailed (no supports), as it is the case for extensional constraints when the number of tuples is 0, the parser respectively calls the methods 
\begin{absc}
  public void buildCtrTrue(String id, XVar[] list)
  public void buildCtrFalse(String id, XVar[] list) 
\end{absc} 
You may wish to override the default behavior of these methods.
\end{remark}

Let us consider now the following instance, called \nn{testPrimitive.xml}, involving three variables $x$, $y$ and $z$ of domain $\{1,2,3,4,5\}$, and five constraints (two of them defined from a group) $x\leq 4$, $x > y$, $y > z$, $x \neq z$ and $x = y+z$.

\begin{boxabsc}
\begin{absc}
<instance format="XCSP3" type="CSP">
  <variables>
    <var id="x"> 0..5 </var>
    <var id="y"> 0..5 </var>
    <var id="z"> 0..5 </var>
  </variables>
  <constraints>
    <intension> le(x,4) </intension>
    <group>
      <intension> gt(%0,%1) </intension>
      <args> x y </args>
      <args> y z </args>
    </group>
    <intension> ne(x,z) </intension>
    <intension> eq(x,add(y,z)) </intension>
  </constraints>
</instance>
\end{absc} 
\end{boxabsc}


When you execute the code for this instance, you must obtain something like:

\begin{boxabsc}
\begin{absc}
Missing Implementation
  Method buildCtrPrimitive
  Class org.xcsp.parser.XCallbacks2
  Line 113
\end{absc} 
\end{boxabsc}

The code for the following method is missing:

\begin{boxabsc}
\begin{absc}
void buildCtrPrimitive(String id, XVarInteger x, TypeConditionOperatorRel op, int k) 
\end{absc} 
\end{boxabsc}

Primitive unary intensional constraints are special cases of intensional constraints.
The parser intercepts them (we shall see later how to deactivate this, if needed).
Primitive unary constraints that can be intercepted have the form:
\begin{quote}
$x \odot k$
\end{quote}
with $x$ being a variable, $\odot \in \{<,\leq,\geq,>,\neq,=\}$ and $k \in \mathbb{Z}$.
For example, we can have $x > 10$ or $y \neq 5$.
If you implement the code for dealing with unary primitive constraints in this method, and run again the code for this instance, you must obtain something like:

\begin{boxabsc}
\begin{absc}
Missing Implementation
  Method buildCtrPrimitive
  Class org.xcsp.parser.XCallbacks2
  Line 117
\end{absc} 
\end{boxabsc}


This time, the code for the following method is missing:

\begin{boxabsc}
\begin{absc}
void buildCtrPrimitive(String id, XVarInteger x, TypeArithmeticOperator opa, XVarInteger y, TypeConditionOperatorRel op, int k) 		
\end{absc} 
\end{boxabsc}
 
Primitive binary intensional constraints are special cases of intensional constraints.
The parser intercepts them (we shall discuss to which extent, later).
Primitive binary constraints that can be intercepted have the form:
\begin{quote}
$(x \oplus y) \odot k$
\end{quote}
with $x$ and $y$ being two variables, $\oplus \in \{+,-,*,/,\%,||\}$, $\odot \in \{<,\leq,\geq,>,\neq,=\}$ and $k \in \mathbb{Z}$.
For example, we can have $x-y>0$ or $|x-y| = 5$ (note that $||$ stands here for the distance between two objects).
If you implement the code for dealing with binary primitive constraints (or a relevant subset of them) in this method, and run again the code for this instance, you must obtain something like:

\begin{boxabsc}
\begin{absc}
Missing Implementation
  Method buildCtrPrimitive
  Class org.xcsp.parser.XCallbacks2
  Line 121
\end{absc} 
\end{boxabsc}


This time, the code for the following method is missing:

\begin{boxabsc}
\begin{absc}
void buildCtrPrimitive(String id, XVarInteger x, TypeArithmeticOperator opa, XVarInteger y, TypeConditionOperatorRel op, XVarInteger z) 
\end{absc} 
\end{boxabsc}

Primitive ternary intensional constraints are special cases of intensional constraints.
The parser intercepts them.
Primitive ternary constraints that can be intercepted have the form:
\begin{quote}
$(x \oplus y) \odot z$
\end{quote}
with $x$, $y$ and $z$ being three variables, $\oplus \in \{+,-,*,/,\%,||\}$, and $\odot \in \{<,\leq,\geq,>,\neq,=\}$.
For example, we can have $x+y=z$ or $x*y > z$.
If you implement the code for dealing with ternary primitive constraints (or a relevant subset of them) in this method, and run again the code for this instance, you should be fine.
Do you get two solutions for this instance?

Maybe, you don't get all these primitive propagators in your solver.
Or you just want to manage yourself the Boolean expressions (predicates) of intension constraints.
Here is how you can proceed.
First, have a look at the following enumeration, put in class \nn{XCallbacks}, together with a predefined map called \nn{callbacksParameters}.

\begin{boxabsc}
\begin{absc}
enum XCallbacksParameters {
  RECOGNIZE_SPECIAL_UNARY_INTENSION_CASES,
  RECOGNIZE_SPECIAL_BINARY_INTENSION_CASES,
  RECOGNIZE_SPECIAL_TERNARY_INTENSION_CASES,
  RECOGNIZE_SPECIAL_COUNT_CASES,
  RECOGNIZE_SPECIAL_NVALUES_CASES,
  INTENSION_TO_EXTENSION_ARITY_LIMIT, // set it to 0 for deactivating "intension to extension" conversion
  INTENSION_TO_EXTENSION_SPACE_LIMIT,
  INTENSION_TO_EXTENSION_PRIORITY;
}

Map<XCallbacksParameters, Object> callbacksParameters = defaultParameters();
\end{absc} 
\end{boxabsc}

If you want to deactivate the recognition of unary and binary primitives constraints, you just have to modify the code of your constructor as follows:

\begin{boxabsc}
\begin{absc}
XCSP3(String fileName) throws Exception {
  callbacksParameters.remove(XCallbacksParameters.RECOGNIZE_SPECIAL_UNARY_INTENSION_CASES);
  callbacksParameters.remove(XCallbacksParameters.RECOGNIZE_SPECIAL_BINARY_INTENSION_CASES);
  loadInstance(fileName); 
}
\end{absc} 
\end{boxabsc}

But of course, you have to implement the following method:

\begin{boxabsc}
\begin{absc}
void buildCtrIntension(String id, XVarInteger[] scope, XNodeParent syntaxTreeRoot) 
\end{absc} 
\end{boxabsc}


For \gb{intension}, we know that \verb!(XNodeExpr) childs[0].value! is an object XNodeExpr that represents the root node of a syntactic tree denoting the Boolean expression.
Let us go further. Suppose that you don't have any propagators for primitive constraints, and you don't have a generic filtering algorithm for dealing with arbitrary form of intensional constraints (after possible decomposition), then your last hope is to convert them into extensional form. The parser can do it for you as follows:

\begin{boxabsc}
\begin{absc}
XCSP3(String fileName) throws Exception {
  callbacksParameters.remove(XCallbacksParameters.RECOGNIZE_SPECIAL_UNARY_INTENSION_CASES);
  callbacksParameters.remove(XCallbacksParameters.RECOGNIZE_SPECIAL_BINARY_INTENSION_CASES); 
  callbacksParameters.remove(XCallbacksParameters.RECOGNIZE_SPECIAL_TERNARY_INTENSION_CASES);
  map.put(XCallbacksParameters.INTENSION_TO_EXTENSION_ARITY_LIMIT, 3); // included
  map.put(XCallbacksParameters.INTENSION_TO_EXTENSION_SPACE_LIMIT, 1000000);
  map.put(XCallbacksParameters.INTENSION_TO_EXTENSION_PRIORITY, Boolean.TRUE);
  loadInstance(fileName); 
}
\end{absc} 
\end{boxabsc}

However, note that we can control the translation, by fixing the maximal arity (here, 3) of intensional constraints to be converted, and the maximal size (here, $1,000,000$) of the Cartesian product of their variable domains. 

\begin{remark}
The way primitive constraints are recognized is not complete. There are some cases where the recognition process may fail.
In the future, we might propose a canonical representation of the syntactic tree to improve things.
\end{remark}

Now, consider the following instance:

\begin{boxabsc}
\begin{absc}
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" note="x[i] is the ith value of the series" size="[5]"> 0..4 </array>
    <array id="y" note="y[i] is the distance between x[i] and x[i+1]" size="[4]"> 1..4 </array>
  </variables>
  <constraints>
    <allDifferent> x[] </allDifferent>
    <allDifferent> y[] </allDifferent>
    <group class="channeling">
      <intension> eq(%0,dist(%1,%2)) </intension>
      <args> y[0] x[0] x[1] </args>
      <args> y[1] x[1] x[2] </args>
      <args> y[2] x[2] x[3] </args>
      <args> y[3] x[3] x[4] </args>
    </group>
  </constraints>
</instance>
\end{absc} 
\end{boxabsc}

If you run your code for this instance, you must obtain something like:

\begin{boxabsc}
\begin{absc}
Missing Implementation
  Method buildCtrAllDifferent
  Class org.xcsp.parser.XCallbacks2
  Line 141
\end{absc} 
\end{boxabsc}

After implementing this method, you should get 8 solutions.
You can keep proceeding that way for all constraints.

If we consider now an optimization problem, with simply a variable to minimize.

\begin{boxabsc}
\begin{absc}
<instance format="XCSP3" type="COP">
  <variables>
    <array id="x" size="[5]"> 0..500 </array>
    <array id="y" size="[5][5]"> 1..500 </array>
  </variables>
  <constraints>
    <group class="channeling">
      <intension> eq(%0,add(%1,%2)) </intension>
      <args> x[1] x[0] y[0][1] </args>
      <args> x[2] x[0] y[0][2] </args>
      <args> x[3] x[0] y[0][3] </args>
      <args> x[4] x[0] y[0][4] </args>
      <args> x[2] x[1] y[1][2] </args>
      <args> x[3] x[1] y[1][3] </args>
      <args> x[4] x[1] y[1][4] </args>
      <args> x[3] x[2] y[2][3] </args>
      <args> x[4] x[2] y[2][4] </args>
      <args> x[4] x[3] y[3][4] </args>
    </group>
    <allDifferent> y[0][1..4] y[1][2..4] y[2][3..4] y[3][4] </allDifferent>
  </constraints>
  <objectives>
    <minimize> x[4] </minimize>
  </objectives>
</instance>
\end{absc} 
\end{boxabsc}


You have to implement the following method:

\begin{boxabsc}
\begin{absc}
void buildObjToMinimize(String id, XVarInteger x) 
\end{absc} 
\end{boxabsc}

Once it is done, do you get 11 as optimal value?

As a last example, let us consider the following quadratic assignment instance.

\begin{boxabsc}
\begin{absc}
<instance format="XCSP3" type="COP">
  <variables>
    <array id="x" size="[12]"> 0..11 </array>
    <array id="d" size="[12][12]"> 0 5 9..12 15..18 21 26 29 30 33..40 44 46 48 54..56 58 59 61 63 64 66 68..70 72 73 76 78..80 83 85 86 90 93 95..97 </array>
  </variables>
  <constraints>
    <allDifferent> x[] </allDifferent>
    <group>
      <extension>
        <list> %0 %1 %2 </list>
        <supports> (0,1,36)(0,2,54) ... (ellipsis here) ... (11,9,86)(11,10,18) </supports>
      </extension>
      <args> x[0..1] d[0][1] </args>
      <args> x[0] x[2] d[0][2] </args>
      <args> x[0] x[3] d[0][3] </args>
      <args> x[0] x[4] d[0][4] </args>
      <args> x[1] x[5] d[1][5] </args>
      <args> x[2] x[6] d[2][6] </args>
      <args> x[2] x[7] d[2][7] </args>
      <args> x[5] x[8] d[5][8] </args>
      <args> x[7] x[9] d[7][9] </args>
      <args> x[8] x[10] d[8][10] </args>
      <args> x[9] x[11] d[9][11] </args>
    </group>
  </constraints>
  <objectives>
    <minimize type="sum">
      <list> d[0][1..4] d[1][5] d[2][6..7] d[5][8] d[7][9] d[8][10] d[9][11] </list>
      <coeffs> 90 10 23 43 88 26 16 1 96 29 37 </coeffs>
    </minimize>
  </objectives>
</instance>
\end{absc} 
\end{boxabsc}

You have to implement the following method:

\begin{boxabsc}
\begin{absc}
void buildObjToMinimize(String id, TypeObjective type, XVarInteger[] list, int[] coeffs) 
\end{absc} 
\end{boxabsc}

Once it is done, do you get $4,776$ as optimal value?




\end{document}




 private DomInteger trDom(XDomInteger xd) {
    Object o = XCallbacks.trDom(xd);
    if (o instanceof int[])
      return new ... // build your DomInteger object from (int[]) o
    else {
        IntegerInterval ii = (IntegerInterval) o;
        int min = XUtility.safeLong2IntWhileHandlingInfinity(ii.inf, true);
        int max = XUtility.safeLong2IntWhileHandlingInfinity(ii.sup, true);
        return new ... // build your DomInteger object from min and max
    }
  }